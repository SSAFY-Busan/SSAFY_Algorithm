# 자리배정

# 어떤 공연장에는 가로로 C개, 세로로 R개의 좌석이 C×R격자형으로 배치되어 있다.
# 각 좌석의 번호는 해당 격자의 좌표 (x,y)로 표시된다.
# 이 공연장에 입장하기 위하여 많은 사람이 대기줄에 서있다. 기다리고 있는 사람들은 제일 앞에서부터
# 1, 2, 3, 4, . 순으로 대기번호표를 받았다. 우리는 대기번호를 가진 사람들에 대하여 (1,1)위치 좌석부터 시작하여
# 시계방향으로 돌아가면서 비어있는 좌석에 관객을 순서대로 배정한다. 이것을 좀 더 구체적으로 설명하면 다음과 같다.
# 먼저 첫 번째 사람, 즉 대기번호 1인 사람은 자리 (1,1)에 배정한다. 그 다음에는 위쪽 방향의 좌석으로 올라가면서
# 다음 사람들을 배정한다. 만일 더 이상 위쪽 방향으로 빈 좌석이 없으면 오른쪽으로 가면서 배정한다.
# 오른쪽에 더 이상 빈자리가 없으면 아래쪽으로 내려간다. 그리고 아래쪽에 더 이상 자리가 없으면 왼쪽으로
# 가면서 남은 빈 좌석을 배정한다. 이 후 왼쪽으로 더 이상의 빈 좌석이 없으면 다시 위쪽으로 배정하고,
# 이 과정을 모든 좌석이 배정될 때까지 반복한다.
# 여러분은 공연장의 크기를 나타내는 자연수 C와 R이 주어져 있을 때,
# 대기 순서가 K인 관객에게 배정될 좌석 번호 (x,y)를 찾는 프로그램을 작성해야 한다.

# 첫 줄에는 공연장의 격자 크기를 나타내는 정수 C와 R이 하나의 공백을 사이에 두고 차례대로 주어진다.
# 두 값의 범위는 5 ≤ C, R ≤ 1,000이다. 그 다음 줄에는 어떤 관객의 대기번호 K가 주어진다. 단 1 ≤ K ≤ 100,000,000이다.


# 인덱스 때문에 해당 문제를 90 도 오른쪽으로 돌려서 생각했다.
#     우 하 좌 상
dr = [0, 1, 0, -1]
dc = [1, 0, -1, 0]

C, R = map(int, input().split())        # 가로 세로를 입력으로 받는다. 그러면 90도 돌린 상태면 반대로 들어간다.
find = int(input())
arr = [[0] * R for _ in range(C)]       # 반대로 가로 => R  세로 => C
d = 0                                   # 방향
r = 0                                   # 행좌표
c = 0                                   # 열좌표
num = 1                                 # 1 부터 숫자 입력
ans = True
while num <= C*R:                       # 숫자범위
    if C == 1 and R == 1:               # 가로세로가 1일경우
        ans1 = 1                        # 1,1 을 넣어서 예외 처리
        ans2 = 1
        break
    arr[r][c] = num                     # 처음에는 1
    if find > C*R:                      # 찾는 숫자가 입력 두수의 곱보다 크면
        ans = False                     # False로 바꿔주고
        break                           # 반복문 종료
    elif find == num:                   # 찾는 숫자의 위치
        ans1, ans2 = r + 1, c + 1       # index 값이므로 1씩 주가
    num += 1                            # 1씩 증가
    nr = r + dr[d]                      # 아래쪽으로 이동
    nc = c + dc[d]
    if 0 <= nr < C and 0 <= nc < R and arr[nr][nc] == 0:   # 세로의 벽은 C 가로의 벽은 R
        r, c = nr, nc                   # 그방향으로 쭉 이등
    else:                               # 벽을 만나면
        d = (d+1) % 4                   # 0 부터 4 까지 반복하기위해서 4로 나눈 나머지
        r += dr[d]                      # 방향 전환 (시계 방향)
        c += dc[d]

# for i in range(C):                      # 세로 먼저
#     for j in range(R):                  # 가로 다음
#         print(arr[i][j], end=' ')       # 배열 나타내는것
#     print()
if ans == True:                         # 아직 ans 가 True 면 값을 찾았다는거니깐
    print(ans1, ans2)                   # 출력
else:                                   # False 면
    print(0)                            # 0 출력

